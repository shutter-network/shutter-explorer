// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: shutter_explorer.sql

package data

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const queryBlockFromSlot = `-- name: QueryBlockFromSlot :one
SELECT block_hash, block_number, block_timestamp, tx_hash, slot, created_at, updated_at FROM block WHERE slot = $1
`

func (q *Queries) QueryBlockFromSlot(ctx context.Context, slot int64) (Block, error) {
	row := q.db.QueryRow(ctx, queryBlockFromSlot, slot)
	var i Block
	err := row.Scan(
		&i.BlockHash,
		&i.BlockNumber,
		&i.BlockTimestamp,
		&i.TxHash,
		&i.Slot,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const queryDecryptionKeyShare = `-- name: QueryDecryptionKeyShare :many
SELECT eon, identity_preimage, keyper_index, decryption_key_share, slot, created_at, updated_at FROM decryption_key_share
WHERE eon = $1 AND identity_preimage = $2 AND keyper_index = $3
`

type QueryDecryptionKeyShareParams struct {
	Eon              int64
	IdentityPreimage []byte
	KeyperIndex      int64
}

func (q *Queries) QueryDecryptionKeyShare(ctx context.Context, arg QueryDecryptionKeyShareParams) ([]DecryptionKeyShare, error) {
	rows, err := q.db.Query(ctx, queryDecryptionKeyShare, arg.Eon, arg.IdentityPreimage, arg.KeyperIndex)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DecryptionKeyShare
	for rows.Next() {
		var i DecryptionKeyShare
		if err := rows.Scan(
			&i.Eon,
			&i.IdentityPreimage,
			&i.KeyperIndex,
			&i.DecryptionKeyShare,
			&i.Slot,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryDecryptionKeysAndMessage = `-- name: QueryDecryptionKeysAndMessage :many
SELECT
    dkm.slot, dkm.tx_pointer, dkm.eon, 
    dk.key, dk.identity_preimage, dkmdk.key_index
FROM decryption_keys_message_decryption_key dkmdk
LEFT JOIN decryption_keys_message dkm ON dkmdk.decryption_keys_message_slot = dkm.slot
LEFT JOIN decryption_key dk ON dkmdk.decryption_key_eon = dk.eon AND dkmdk.decryption_key_identity_preimage = dk.identity_preimage
WHERE dkm.slot = $1 ORDER BY dkmdk.key_index ASC
`

type QueryDecryptionKeysAndMessageRow struct {
	Slot             pgtype.Int8
	TxPointer        pgtype.Int8
	Eon              pgtype.Int8
	Key              []byte
	IdentityPreimage []byte
	KeyIndex         int64
}

func (q *Queries) QueryDecryptionKeysAndMessage(ctx context.Context, slot int64) ([]QueryDecryptionKeysAndMessageRow, error) {
	rows, err := q.db.Query(ctx, queryDecryptionKeysAndMessage, slot)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []QueryDecryptionKeysAndMessageRow
	for rows.Next() {
		var i QueryDecryptionKeysAndMessageRow
		if err := rows.Scan(
			&i.Slot,
			&i.TxPointer,
			&i.Eon,
			&i.Key,
			&i.IdentityPreimage,
			&i.KeyIndex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryGreeter = `-- name: QueryGreeter :many
SELECT hello from greeter
`

func (q *Queries) QueryGreeter(ctx context.Context) ([]string, error) {
	rows, err := q.db.Query(ctx, queryGreeter)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var hello string
		if err := rows.Scan(&hello); err != nil {
			return nil, err
		}
		items = append(items, hello)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const queryTransactionSubmittedEvent = `-- name: QueryTransactionSubmittedEvent :many
SELECT event_block_hash, event_block_number, event_tx_index, event_log_index, eon, tx_index, identity_prefix, sender, encrypted_transaction, created_at, updated_at FROM transaction_submitted_event
WHERE eon = $1 AND tx_index >= $2 AND tx_index < $2 + $3 ORDER BY tx_index ASC
`

type QueryTransactionSubmittedEventParams struct {
	Eon     int64
	TxIndex int64
	Column3 interface{}
}

func (q *Queries) QueryTransactionSubmittedEvent(ctx context.Context, arg QueryTransactionSubmittedEventParams) ([]TransactionSubmittedEvent, error) {
	rows, err := q.db.Query(ctx, queryTransactionSubmittedEvent, arg.Eon, arg.TxIndex, arg.Column3)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []TransactionSubmittedEvent
	for rows.Next() {
		var i TransactionSubmittedEvent
		if err := rows.Scan(
			&i.EventBlockHash,
			&i.EventBlockNumber,
			&i.EventTxIndex,
			&i.EventLogIndex,
			&i.Eon,
			&i.TxIndex,
			&i.IdentityPrefix,
			&i.Sender,
			&i.EncryptedTransaction,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
